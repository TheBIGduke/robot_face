<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OctopID Moods - Always Listening</title>
    <style>
        :root {
            --face-color: #40D4D6;
            --background-color: black;
            --text-color: #f0f0f0;
        }

        /* MODIFICATION: Ensure no extra space on the page */
        html, body {
            height: 105%;
            width: 100%;
            overflow: hidden; /* Prevents scrollbars */
        }

        body {
            display: flex;
            justify-content: center;
            align-items: flex-end;
            background-color: var(--background-color);
            padding-top: 6%;
        }

        .container {
            width: 100%;
            height: 135%;
        }

        /* MODIFICATION: Let SVG fill the container */
        #face {
            width: 100%;
            height: 100%;
        }

        .eye-background, .eye-icon-container path {
            transition: d 0.3s ease-in-out, fill 0.3s ease-in-out,
                        stroke 0.3s ease-in-out, transform 0.3s ease-in-out;
            transform-origin: center;
        }

        #mouth {
            transition: d 0.1s linear;
        }

        .eye {
            transition: transform 0.4s ease-in-out;
            transform-origin: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <svg id="face" viewBox="0 0 200 200" preserveAspectRatio="xMidYMid meet">
            <g class="eye" id="left-eye">
                <path class="eye-background" d="M 5,110 L 5,80 A 15,30 0 0,1 35,80 L 35,110 Z" />
                <g class="eye-icon-container"></g>
            </g>

            <g class="eye" id="right-eye">
                <path class="eye-background" d="M 165,110 L 165,80 A 15,30 0 0,1 195,80 L 195,110 Z" />
                <g class="eye-icon-container"></g>
            </g>

            <path
                id="mouth"
                stroke-width="5"
                fill="transparent"
                stroke-linecap="round"/>
        </svg>
    </div>

    <script>
        const mouth = document.getElementById('mouth');
        const leftEye = document.querySelector('#left-eye .eye-background');
        const rightEye = document.querySelector('#right-eye .eye-background');
        const eyes = document.querySelectorAll('.eye');
        const leftEyeIcon = document.querySelector('#left-eye .eye-icon-container');
        const rightEyeIcon = document.querySelector('#right-eye .eye-icon-container');
        const root = document.documentElement;

        let currentMood = 'neutral';
        let webSocket;
        let audioAnimationId;
        let isWideEyed = false;
        let currentPanX = 0;
        let currentPanY = 0;

        let targetMouthPath = '';
        let currentMouthPath = '';
        
        // --- UPDATED TALKING MOUTH PATHS (Sweep Flag 0) ---
        let isTalking = false; // Tracks if the mouth is currently in an audio-driven state
        let talkingTimeout = null; // Timer to switch back to the mood path after audio ends
        // Set sweep flag (7th number) to 0 for a downward curve
        // Set Y-radius to 0.1 (from 0) to maintain arc structure for interpolation
        const TALKING_MOUTH_CLOSED_PATH = 'M 60 130 A 40 0.1 0 0 0 140 130 Z'; 
        // -----------------------------------------------------

        /* ====================================================================
           EYE ANIMATION - PANNING
           ==================================================================== */
        const panEyes = () => {
            if (['wink', 'dizzy', 'love'].includes(currentMood)) {
                return;
            }

            currentPanX = Math.random() * 20 - 10;
            currentPanY = Math.random() * 12 - 6;

            eyes.forEach(eye => {
                eye.style.transform = `translate(${currentPanX}px, ${currentPanY}px) scaleY(1)`;
            });
        };
        setInterval(panEyes, Math.random() * 4000 + 3000);

        /* ====================================================================
           EYE ANIMATION - BLINKING
           ==================================================================== */
        const blink = () => {
            if (isWideEyed || ['wink'].includes(currentMood)) return;

            const blinkTransitionSpeed = '0.1s';

            eyes.forEach(eye => {
                eye.style.transitionDuration = blinkTransitionSpeed;
                eye.style.transform = `translate(${currentPanX}px, ${currentPanY}px) scaleY(0.1)`;
            });

            setTimeout(() => {
                if (!isWideEyed) {
                    eyes.forEach(eye => {
                        eye.style.transform = `translate(${currentPanX}px, ${currentPanY}px) scaleY(1)`;
                    });
                }
            }, 150);
        };
        setInterval(blink, Math.random() * 5000 + 2000);


        /* ====================================================================
           MOOD DEFINITIONS
           ==================================================================== */
        const moods = {
            neutral: {
                color: '#40D4D6',
                mouthPath: 'M 60 130 L 140 130',
                leftEyePath: 'M 5,110 L 5,80 A 15,30 0 0,1 35,80 L 35,110 Z',
                rightEyePath: 'M 165,110 L 165,80 A 15,30 0 0,1 195,80 L 195,110 Z',
            },

            happy: {
                color: '#6AF2A0',
                mouthPath: 'M 60 130 Q 100 150 140 130',
                leftEyePath: 'M 5,100 A 15,40 0 0,1 35,100',
                rightEyePath: 'M 165,100 A 15,40 0 0,1 195,100',
            },

            sad: {
                color: '#5B8DEF',
                mouthPath: 'M 60 140 Q 100 120 140 140',
                leftEyePath: 'M 5,90 A 15,40 0 0,0 35,90',
                rightEyePath: 'M 165,90 A 15,40 0 0,0 195,90',
            },

            angry: {
                color: '#E74C3C',
                mouthPath: 'M 60 140 L 140 140',
                leftEyePath: 'M 5,60 L 35,80 L 35,110 L 5,110 Z',
                rightEyePath: 'M 165,75 L 195,60 L 195,110 L 165,110 Z',
            },

            surprised: {
                color: '#F1C40F',
                mouthPath: 'M 90 130 A 10 15 0 1 0 110 130 A 10 15 0 1 0 90 130 Z',
                leftEyePath: 'M 5,115 L 5,75 A 15,35 0 0,1 35,75 L 35,115 Z',
                rightEyePath: 'M 165,115 L 165,75 A 15,35 0 0,1 195,75 L 195,115 Z',
            },

            love: {
                color: '#E87AF2',
                mouthPath: 'M 60 130 Q 100 145 140 130',
                leftEyePath: 'M 20,100 C 0,80 0,55 20,65 C 40,55 40,80 20,100 Z',
                rightEyePath: 'M 180,100 C 160,80 160,55 180,65 C 200,55 200,80 180,100 Z',
            },

            dizzy: {
                color: '#9B59B6',
                mouthPath: 'M 60 135 Q 80 125, 100 135 T 140 135',
                leftEyePath: 'M 20,95 m -18,0 a18,18 0 1,1 36,0 a12,12 0 1,1 -24,0 a6,6 0 1,1 12,0',
                rightEyePath: 'M 180,95 m -18,0 a18,18 0 1,1 36,0 a12,12 0 1,1 -24,0 a6,6 0 1,1 12,0',
            },

            doubtful: {
                color: '#3498DB',
                mouthPath: 'M 70 135 L 130 125',
                leftEyePath: 'M 15,110 L 15,80 A 15,30 0 0,1 45,80 L 45,110 Z',
                rightEyePath: 'M 175,110 L 175,80 A 15,30 0 0,1 205,80 L 205,110 Z',
            },

            wink: {
                color: '#FFB84D',
                mouthPath: 'M 60 130 Q 100 135 140 125',
                leftEyePath: 'M 5,110 L 5,80 A 15,30 0 0,1 35,80 L 35,110 Z',
                rightEyePath: 'M 160,80 A 15,5 0 0,1 195,80',
            },

            scared: {
                color: '#A8ECF0', // Changed color for visibility
                mouthPath: 'M 80 145 L 95 135 L 110 145 L 125 135 L 140 145',
                leftEyePath: 'M 5,115 L 5,75 A 15,35 0 0,1 35,75 L 35,115 Z',
                rightEyePath: 'M 165,115 L 165,75 A 15,35 0 0,1 195,75 L 195,115 Z',
            },

            disappointed: {
                color: '#BCA0DC',
                mouthPath: 'M 70 135 Q 90 145, 110 135 T 140 140',
                leftEyePath: 'M 5,110 L 5,80 A 15,30 0 0,1 35,80 L 35,110 Z',
                rightEyePath: 'M 165,80 A 15,40 0 0,0 195,80',
            },

            innocent: {
                color: '#E0E0E0',
                mouthPath: 'M 90 135 Q 100 140 110 135',
                leftEyePath: 'M 5,115 L 5,75 A 15,35 0 0,1 35,75 L 35,115 Z',
                rightEyePath: 'M 165,115 L 165,75 A 15,35 0 0,1 195,75 L 195,115 Z',
            },

            worried: {
                color: '#7f8c8d',
                mouthPath: 'M 60 145 Q 100 135 140 145',
                leftEyePath: 'M 5,80 L 35,60 L 35,110 L 5,110 Z',
                rightEyePath: 'M 165,60 L 195,80 L 195,110 L 165,110 Z',
            }
        };

        /* ====================================================================
           CORE FUNCTION - setMood()
           ==================================================================== */
        function setMood(name) {
            // Cancel any pending audio-end timeout if a mood command is received
            if (talkingTimeout) {
                clearTimeout(talkingTimeout);
                talkingTimeout = null;
            }
            isTalking = false; // Force out of talking state

            currentPanX = 0;
            currentPanY = 0;
            eyes.forEach(eye => {
                eye.style.transitionDuration = '0.4s';
                eye.style.transform = 'translate(0, 0) scaleY(1)';
            });

            isWideEyed = (name === 'surprised');
            currentMood = name;
            const expr = moods[name];

            if (!expr) return;

            root.style.setProperty('--face-color', expr.color);

            mouth.setAttribute('stroke', 'var(--face-color)');
            mouth.setAttribute('d', expr.mouthPath); // Immediately set mood mouth path
            
            // Set fill to transparent when setting a new mood
            // (unless the mood itself is supposed to be filled, e.g. surprised)
            if (name === 'surprised') {
                 mouth.style.fill = 'var(--face-color)';
            } else {
                 mouth.style.fill = 'transparent';
            }


            leftEye.setAttribute('fill', 'var(--face-color)');
            leftEye.setAttribute('d', expr.leftEyePath);

            rightEye.setAttribute('fill', 'var(--face-color)');
            rightEye.setAttribute('d', expr.rightEyePath);

            if (expr.icon) {
                leftEyeIcon.innerHTML = expr.icon;
                rightEyeIcon.innerHTML = expr.icon;
                leftEyeIcon.querySelectorAll('path').forEach(p => {
                    if (p.getAttribute('fill') !== 'none') p.setAttribute('fill', expr.color);
                });
                rightEyeIcon.querySelectorAll('path').forEach(p => {
                    if (p.getAttribute('fill') !== 'none') p.setAttribute('fill', expr.color);
                });
            } else {
                leftEyeIcon.innerHTML = '';
                rightEyeIcon.innerHTML = '';
            }
        }

        /* ====================================================================
           WEBSOCKET LOGIC - ALWAYS LISTENING MODE
           ==================================================================== */
        function connectWebSocket() {
            const serverAddress = 'ws://localhost:8760'; // Modifiy the server address if needed
            webSocket = new WebSocket(serverAddress);

            webSocket.onopen = () => {
                console.log('Successfully connected to the WebSocket server');
                targetMouthPath = moods.neutral.mouthPath;
                currentMouthPath = moods.neutral.mouthPath;

                webSocket.onmessage = (event) => {
                    const data = JSON.parse(event.data); // Parses the incoming JSON into a JS object

                    if (data.type === 'audio') { // Verifies if the data is audio
                        const bassLevel = data.bass;
                        const talkingThreshold = 0.1;

                        if (bassLevel > talkingThreshold) {
                            // --- Audio is active ---
                            // Clear any pending timeout to switch back to mood path
                            if (talkingTimeout) {
                                clearTimeout(talkingTimeout);
                                talkingTimeout = null;
                            }
                            isTalking = true;

                            // Calculates mouth openness based on bass level
                            const mouthOpenness = bassLevel * 40;
                            // Set the target path to an open arc based on audio (sweep flag 0 for downward curve)
                            targetMouthPath = `M 60 130 A 40 ${mouthOpenness} 0 0 0 140 130 Z`;
                            mouth.style.fill = 'var(--face-color)';
                        } else {
                            // --- Audio dropped below threshold ---
                            if (isTalking) {
                                // If we were just talking, set target to closed arc for smooth interpolation
                                targetMouthPath = TALKING_MOUTH_CLOSED_PATH;
                                
                                // Set a timeout to switch back to the original mood path after a small delay
                                if (!talkingTimeout) {
                                    // *** MODIFICATION: Increased timeout ***
                                    talkingTimeout = setTimeout(() => {
                                        isTalking = false; // We are no longer governed by audio
                                        targetMouthPath = moods[currentMood].mouthPath;
                                        // Set fill to transparent AFTER animation
                                        if (currentMood !== 'surprised') { // Don't hide surprised mouth
                                            mouth.style.fill = 'transparent';
                                        }
                                        talkingTimeout = null;
                                    }, 300); // 300ms delay to allow the slower animation to finish
                                }
                            } else {
                                // Not talking and not transitioning, maintain mood path
                                targetMouthPath = moods[currentMood].mouthPath;
                            }
                        }
                    } else if (data.type === 'mood') { // Checks if the data is a mood command
                        console.log(`Received mood command: ${data.mood}`);
                        setMood(data.mood);
                    }
                };
                animateMouth();
            };
            
            // If the connection drops, it will try to reconnect
            webSocket.onclose = () => {
                console.log('Disconnected from the WebSocket server');
                // Clear state on disconnect
                if (talkingTimeout) clearTimeout(talkingTimeout);
                isTalking = false;
                talkingTimeout = null;

                setTimeout(connectWebSocket, 3000);
            };

            webSocket.onerror = (error) => {
                console.error('WebSocket error:', error);
            };
        }

        /* ====================================================================
           ANIMATION LOOP - Mouth Position Interpolation
           ==================================================================== */
        const animateMouth = () => {
            if (!webSocket || webSocket.readyState !== WebSocket.OPEN) {
                audioAnimationId = requestAnimationFrame(animateMouth);
                return;
            }

            const currentPoints = (currentMouthPath.match(/[-+]?[0-9]*\.?[0-9]+/g) || []).map(Number);
            const targetPoints = (targetMouthPath.match(/[-+]?[0-9]*\.?[0-9]+/g) || []).map(Number);
            let newPath;

            if (currentPoints.length !== targetPoints.length) {
                newPath = targetMouthPath;
            } else {
                const newPoints = currentPoints.map((point, i) =>
                    // *** MODIFICATION: Slower interpolation ***
                    point + (targetPoints[i] - point) * 0.15
                );

                // --- Robust path reconstruction based on point count ---
                if (newPoints.length === 4) { // M L (Neutral, Angry, Doubtful)
                    newPath = `M ${newPoints[0]} ${newPoints[1]} L ${newPoints[2]} ${newPoints[3]}`;
                
                } else if (newPoints.length === 6) { // M Q (Happy, Sad, Love, Wink, Innocent)
                    newPath = `M ${newPoints[0]} ${newPoints[1]} Q ${newPoints[2]} ${newPoints[3]} ${newPoints[4]} ${newPoints[5]}`;
                
                } else if (newPoints.length === 8) { // M Q T (Dizzy, Disappointed)
                     newPath = `M ${newPoints[0]} ${newPoints[1]} Q ${newPoints[2]} ${newPoints[3]}, ${newPoints[4]} ${newPoints[5]} T ${newPoints[6]} ${newPoints[7]}`;
                
                } else if (newPoints.length === 9) { // M A Z (Talking Arc)
                    newPath = `M ${newPoints[0]} ${newPoints[1]} A ${newPoints[2]} ${newPoints[3]} ${newPoints[4]} ${newPoints[5]} ${newPoints[6]} ${newPoints[7]} ${newPoints[8]} Z`;
                
                } else if (newPoints.length === 10) { // M L L L L (Scared)
                     newPath = `M ${newPoints[0]} ${newPoints[1]} L ${newPoints[2]} ${newPoints[3]} L ${newPoints[4]} ${newPoints[5]} L ${newPoints[6]} ${newPoints[7]} L ${newPoints[8]} ${newPoints[9]}`;

                } else if (newPoints.length === 21) { // M A A Z (Surprised)
                    newPath = `M ${newPoints[0]} ${newPoints[1]} A ${newPoints[2]} ${newPoints[3]} ${newPoints[4]} ${newPoints[5]} ${newPoints[6]} ${newPoints[7]} ${newPoints[8]} A ${newPoints[9]} ${newPoints[10]} ${newPoints[11]} ${newPoints[12]} ${newPoints[13]} ${newPoints[14]} ${newPoints[15]} Z`;
                
                } else {
                    // Fallback: just snap to target
                    newPath = targetMouthPath;
                }
            }
            currentMouthPath = newPath;
            mouth.setAttribute('d', newPath);
            audioAnimationId = requestAnimationFrame(animateMouth);
        };

        window.addEventListener('DOMContentLoaded', () => {
            setMood('neutral');
            connectWebSocket();
        });

    </script>
</body>
</html>